#ifndef __LINKED_LIST_CPP_9F4861BC
#define __LINKED_LIST_CPP_9F4861BC

//Name: Noel Negusse
//UT EID: ntn443

#include <iostream>
#include <string>
#include <sstream>

using std::string;
using std::stringstream;
using std::ostream;
using std::istream;
using std::cout;
using std::endl;

template <class type>
class LinkedList{
	template<class Q> friend class PriorityQueue;
//PROTECTED+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//NODE AND VARIABLES++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	protected:
	public:	        
		struct node{
			type val;
			node *next;
			bool operator<(const node& n) const{
				cout << "<" << endl;
				if(this->val < n.val)
					return true;
				return false;
			}

			bool operator<=(const node& n) const{
				cout << "<=" << endl;
				if(!(this->val > n.val))
					return true;
				return false;
			}
		
			bool operator>(const node& n) const{
					cout << ">" << endl;
				if (this->val > n.val)
					return true;
				return false;
			}

			bool operator>=(const node& n) const{
				cout << ">=" << endl;
				if(!(this->val < n.val))
					return true;
				return false;
			}
		};

		node* head; //head of list
		node* path; //tail of list
		int s; //counts size of list
//PUBLIC++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//CONSTRUCTORS AND DESTRCUTORS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	public:
		LinkedList(): s(0), head(NULL), path(NULL){}
		LinkedList(type x){
			this->head = new node;
			(this->head)->val = x;
			(this->head)->next = NULL;
			this->path = head;
			this->s = 1;
		} 
		//Copy Constructor
		LinkedList(const LinkedList& list): s(0), head(NULL), path(NULL){
			if(list.head != NULL){
				head = new node; 
				node* temp;
				temp = list.head;
				head->val = temp->val; 
				head->next = temp->next;
				path = head; s = 1;
				while(temp->next != NULL){
					temp = temp->next;
					push(temp->val);
				}
				s = list.s; //Safety Measure	
			}
		}

		LinkedList<type>& operator=(const LinkedList& list){
			if(this!=&list){	//Making sure they aren't the same Memory Address
				path = head;
				if(path != NULL){
					while(path->next != NULL){
						this->pop();
						path = path->next;
					} //Deallocate Path & Head	
					this->pop();			
					path = NULL;
				}
				if(list.head != NULL){
					head = new node; 
					node* temp;
					temp = list.head;
					head->val = temp->val; 
					head->next = temp->next;
					path = head; s = 1;
					while(temp->next != NULL){
						temp = temp->next;
						push(temp->val);
					}
					s = list.s; //Safety Measure	
				}
			}
			return *this;
		}
		
		//Destructor - iterates through the remainder of nodes and deletes them (pops them)
		//eventually setting head to NULL
	       	~LinkedList(){			
 			path = head;
			if(path != NULL){
				while(path->next != NULL){
					this->pop();
					path = path->next;
				}
				this->pop();			
				path = NULL;
			}		
		}

//FRIEND FUNCTIONS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		template<class R>
		friend ostream& operator<<(ostream& out, LinkedList<type>& list);
		template<class R>
		friend istream& operator>>(istream& in, LinkedList<type>& list);

//OPERATOR OVERLOADERS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		bool operator==(const LinkedList<type>& list) const{
			if(list.head == NULL && this->head == NULL)
				return true;
			if(list.s  == s){
			 	node* temp = list.head;
				node* temp2 = head;
				while(temp->next != NULL && temp2->next!=NULL){
					if(temp->val != temp2->val)
						return false;
					temp = temp->next;
					temp2 = temp2->next;
				}
				if(temp->val == temp2->val)
					return true;
			}
			return false;
		}

		bool operator!=(const LinkedList& list) const{
			return !(*this == list);
		}

		LinkedList<type> operator+(const type v) const{
			LinkedList<type> tempC = *this;
			tempC.push(v);
			return tempC;
		}

		LinkedList<type> operator+(const LinkedList<type>& list) const{
			node* temp = list.head;
			LinkedList<type> tempC = *this;
			while(temp->next != NULL){
				tempC = tempC + temp.val; //Using the previous operator overloader
				temp = temp->next;
			}
			tempC = tempC + temp.val;
			return tempC;
		}

		LinkedList<type> operator-(const type v) const{
			if(head == NULL) { return NULL; }
			LinkedList<type> tempC = *this;
			node* temp = tempC.head;
			while(temp->next != NULL){
				if(temp->val == v)
					tempC.popAnywhere(temp);
				temp = temp->next;
			}
			if(temp->val == v)
				tempC.popAnywhere(temp);
			return tempC;
		}

		LinkedList<type> operator-(const LinkedList<type>& list) const{
			LinkedList<type> tempC = *this;
			if(tempC.head == NULL) return NULL;
			node* temp = list.head;
			while(temp->next != NULL){
				tempC = tempC - (temp->val);
				temp = temp->next;
			}
			tempC = tempC - (temp->val);
			return tempC;
		}

		type& operator[](const type x) const{
			try{
				if(x >= s){
					throw 10;
				}
				else{
					node* temp = head;
					for(int i = 0; i<x; i++){
						temp = temp->next;
					}
					return temp->val;
				}
			}
			catch(...){
				cout << "Exception: Out of bounds" << endl;
			}
		}
		
//NORMAL FUNCTIONS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		virtual type push(type x){
			if(head == NULL && path == NULL && s == 0){
				reset(x);
			}
			else{
				path->next = new node;
				path = path->next;
				path->val = x;
				path->next = NULL;
				s++;
			}
		}
		
		void reset(type x){		
			this->head = new node;
			(this->head)->val = x;
			(this->head)->next = NULL;
			this->path = head;
			this->s = 1;
		}
		
		void popAnywhere(node* c){
			node* h = head;
			if(c->val == h->val){//POP HEAD
				pop();
			}
			else{	
				while(h->next != c && h->next != NULL){//ITTERATE TO RIGHT NODE
					h = h->next;
				}
				if(c->next == NULL){//POP END
					h->next = NULL;	
				}
				if(c->next != NULL){//POP FROM MIDDLE
					h->next = c->next;
				}
			}
		}

		//SUPPORT EXCEPTIONS WHEN CALLED ON EMPTY LIST
		type pop(){//POPS HEAD
			try{
				if(head == NULL){
					throw 10;
				}
				else{
					node *temp = head;
					head = head->next;
					delete temp;
					s--;
					if(head != NULL)
						return head->val;
					return NULL;	
				}
			}
			catch(...){
				cout << "Exception: Cannot call pop to an empty list" << endl;
					return NULL;
			}		
		}

		void print(){
			path = head;
			if(path != NULL){
				while(path->next != NULL){
					cout << path->val << " ";
					path = path->next;
				}
				cout << path->val << endl;
			}
		}
		
		string sprint(){
			node* path2 = head; 
			stringstream output;
			if(path2 != NULL){
				while(path2->next != NULL){
					output << path2->val << " ";
					path2 = path2->next;
				}
				output << path2->val;;
			}
			string s = output.str();
			return s;
		}
		
		int size(){
			return s;	
		}
	
		node* getHead(){
			return head;
		}

		node* getPath(){
			return path;
		}

		type peek(){
			return head->val;
		}
};

template <class type> 
ostream& operator<< (ostream& out, LinkedList<type>& list){//change back const
	string s = list.sprint();
	out << s << endl;
	return out;
} 

template <class type> 
istream& operator>> (istream& in, LinkedList<type>& list){
	type newval;
	in >> newval;
	list.push(newval);
	return in;
}


#endif
