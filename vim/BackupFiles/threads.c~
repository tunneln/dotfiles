#include <stdlib.h>
#include <setjmp.h>
#include "threads.h"
#include <stdio.h>

struct thread{
	int check;
 	jmp_buf env;
	void *stack;
	void (*func)(void*);
	void *arg;
	thread *next;
};

thread *thread_create(void (*f)(void *arg), void *arg){
	thread* foo; ++counter;
	foo = malloc(sizeof(thread));
	if(foo == NULL){ return NULL; }
	foo->check = 0;
	void *stackpointer;
	posix_memalign(&stackpointer, 8, 128*1024);
	foo->arg = arg;
	foo->func = f;
	foo->stack = stackpointer;
	if(counter == 1){ foo->next = foo; current_thread = foo; tail = foo;}
	else {foo->next = current_thread;}
//	printf("Stack Pointer %p\n", foo->stack);
	return foo;
};

void thread_add_runqueue(struct thread *t){
	if(counter == 1){}//Don't do shit if it's the first thread coming in
	else{
		tail->next = t;
		tail = tail->next;
	}
}

void thread_yield(void){
	if((!setjmp(current_thread->env))){ //true if coming from longjump (resotred it's state)
		schedule();
		dispatch();
	}
}

void dispatch(void){
	if(current_thread->check == 0){			
		current_thread->check = 1;
		__asm__ volatile("mov %%rax, %%rsp" : : "a" (current_thread->stack + 1024*128) );
		__asm__ volatile("mov %%rax, %%rbp" : : "a" (current_thread->stack + 1024*128) );
		current_thread->func(current_thread->arg);
		thread_exit();
	}
	else{ longjmp(current_thread->env, 1); }
}

void schedule(void){
	current_thread = current_thread->next;
	tail = tail->next;
}

void thread_exit(void){
//	printf("Thread: %d\n", current_thread);
//	printf("Stack Pointer in Thread %p\n", current_thread->stack);
	printf("Current Thread  #%d\n", *((int*) current_thread->arg));//  TEST FUNCTIONS!!
	if(exited != NULL){
		printf("Exiting Thread  #%d\n", *((int*) exited->arg));//  TEST FUNCTIONS!!
		free(exited->stack);
		free(exited);
	}
	if(current_thread->next == current_thread){
		longjmp(master, 1);
	}
	exited = current_thread;
	current_thread = current_thread->next;
	printf("New Current Thread%d\n", *((int*) current_thread->arg));
	tail->next = current_thread;
	dispatch();
}

void thread_start_threading(void){
	if(setjmp(master)){
		free(exited->stack);
		free(exited);
//		free(current_thread->stack);
		free(current_thread);
		return;
	}
	exited = NULL;
	schedule();
	dispatch();
}

